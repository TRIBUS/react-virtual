{"version":3,"file":"react-virtual.production.min.js","sources":["../node_modules/@reach/observe-rect/dist/observe-rect.esm.js","../src/useIsomorphicLayoutEffect.js","../src/useRect.js","../src/index.js","../src/useWindowRect.js"],"sourcesContent":["var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(nodeRef) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, null)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect();\n      dispatch({ rect });\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect });\n    });\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nexport function useWindowRect(windowObj, nodeRef) {\n  const [rect, dispatch] = React.useReducer(rectReducer, null)\n  useIsomorphicLayoutEffect(() => {\n    dispatch({\n      rect: {\n        height: windowObj.innerHeight,\n        width: windowObj.innerWidth,\n      }\n    });\n  }, [windowObj])\n\n  React.useEffect(() => {\n    const resizeHandler = () => {\n      dispatch({\n        rect: {\n          height: windowObj.innerHeight,\n          width: windowObj.innerWidth,\n        }\n      });\n    };\n    resizeHandler();\n    windowObj.addEventListener(\"resize\", resizeHandler);\n    return () => {\n      windowObj.removeEventListener(\"resize\", resizeHandler);\n    };\n  }, [nodeRef, windowObj]);\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (!state || state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n\n","import React from 'react'\n\nimport useRect from './useRect'\nimport useWindowRect from './useWindowRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nconst defaultKeyExtractor = index => index\n\nconst defaultMeasureSize = (el, horizontal) => {\n  const key = horizontal ? 'offsetWidth' : 'offsetHeight'\n\n  return el[key]\n}\n\nexport const defaultRangeExtractor = range => {\n  const start = Math.max(range.start - range.overscan, 0)\n  const end = Math.min(range.end + range.overscan, range.size - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport function useVirtualWindow({\n  windowRef,\n  scrollToFn,\n  horizontal,\n  parentRef,\n  ...rest\n}) {\n  const scrollKey = horizontal ? 'scrollX' : 'scrollY'\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (windowRef.current) {\n        windowRef.current[scrollKey] = offset\n      }\n    },\n    [scrollKey, windowRef]\n  )\n\n  return useVirtual({\n    ...rest,\n    horizontal,\n    parentRef,\n    scrollToFn: scrollToFn || defaultScrollToFn,\n    onScrollElement: windowRef,\n    scrollOffsetFn() {\n      const bounds = parentRef.current.getBoundingClientRect();\n      return horizontal ? bounds.left * -1 : bounds.top * -1;\n    },\n    useObserver: () => useWindowRect(windowRef),\n  });\n}\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 1,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  onScrollElement,\n  scrollOffsetFn,\n  keyExtractor = defaultKeyExtractor,\n  measureSize = defaultMeasureSize,\n  rangeExtractor = defaultRangeExtractor,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n  const latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: [],\n  })\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef) || {\n    [sizeKey]: 0,\n  }\n  latestRef.current.outerSize = outerSize\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  scrollToFn = React.useCallback(\n    offset => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measure = React.useCallback(() => setMeasuredCache({}), [])\n\n  const pendingMeasuredCacheIndexesRef = React.useRef([])\n\n  const measurements = React.useMemo(() => {\n    const min =\n      pendingMeasuredCacheIndexesRef.current.length > 0\n        ? Math.min(...pendingMeasuredCacheIndexesRef.current)\n        : 0\n    pendingMeasuredCacheIndexesRef.current = []\n\n    const measurements = latestRef.current.measurements.slice(0, min)\n\n    for (let i = min; i < size; i++) {\n      const key = keyExtractor(i)\n      const measuredSize = measuredCache[key]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end, key }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor])\n\n  const totalSize = (measurements[size - 1]?.end || 0) + paddingEnd\n\n  latestRef.current.measurements = measurements\n  latestRef.current.totalSize = totalSize\n\n  const [range, setRange] = React.useState({ start: 0, end: 0 })\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n\n  const scrollOffsetFnRef = React.useRef(scrollOffsetFn)\n  scrollOffsetFnRef.current = scrollOffsetFn\n\n  const rangeTimeoutIdRef = React.useRef(null)\n\n  const cancelAsyncRange = React.useCallback(() => {\n    if (rangeTimeoutIdRef.current !== null) {\n      clearTimeout(rangeTimeoutIdRef.current)\n      rangeTimeoutIdRef.current = null\n    }\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    rangeTimeoutIdRef.current = setTimeout(() => {\n      setRange(prevRange => calculateRange(latestRef.current, prevRange))\n    })\n    return () => cancelAsyncRange()\n  }, [measurements, outerSize, cancelAsyncRange])\n\n  useIsomorphicLayoutEffect(() => {\n    if (!element) {\n      setRange({ start: 0, end: 0 })\n      latestRef.current.scrollOffset = 0\n\n      return\n    }\n\n    const onScroll = event => {\n      const scrollOffset = scrollOffsetFnRef.current\n        ? scrollOffsetFnRef.current(event)\n        : element[scrollKey]\n\n      latestRef.current.scrollOffset = scrollOffset\n\n      cancelAsyncRange()\n      setRange(prevRange => calculateRange(latestRef.current, prevRange))\n    }\n\n    // Determine initially visible range\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey, cancelAsyncRange])\n\n  const measureSizeRef = React.useRef(measureSize)\n  measureSizeRef.current = measureSize\n\n  const virtualItems = React.useMemo(() => {\n    const indexes = rangeExtractor({\n      start: range.start,\n      end: range.end,\n      overscan,\n      size: measurements.length,\n    })\n\n    const virtualItems = []\n\n    for (let k = 0, len = indexes.length; k < len; k++) {\n      const i = indexes[k]\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          if (el) {\n            const measuredSize = measureSizeRef.current(el, horizontal)\n\n            if (measuredSize !== item.size) {\n              const { scrollOffset } = latestRef.current\n\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i)\n\n              setMeasuredCache(old => ({\n                ...old,\n                [item.key]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [\n    defaultScrollToFn,\n    horizontal,\n    measurements,\n    overscan,\n    range.end,\n    range.start,\n    rangeExtractor,\n  ])\n\n  const mountedRef = React.useRef()\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      if (estimateSize) setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (toOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset)\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n          ? measurement.end\n          : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n    measure,\n  }\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    let middle = ((low + high) / 2) | 0\n    let currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({ measurements, outerSize, scrollOffset }, prevRange) {\n  const size = measurements.length - 1\n  const getOffset = index => measurements[index].start\n\n  let start = findNearestBinarySearch(0, size, getOffset, scrollOffset)\n  let end = start\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++\n  }\n\n  if (prevRange.start !== start || prevRange.end !== end) {\n    return { start, end }\n  }\n\n  return prevRange\n}\n","import * as React from 'react'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useWindowRect(windowRef) {\n  const [rect, setRect] = React.useState({ height: undefined, width: undefined })\n\n  const element = windowRef.current\n\n  useIsomorphicLayoutEffect(() => {\n    const resizeHandler = () => {\n      const next = {\n        height: element.innerHeight,\n        width: element.innerWidth,\n      }\n      setRect(prev => (prev.height !== next.height || prev.width !== next.width ? next : prev))\n    }\n    resizeHandler()\n\n    element.addEventListener('resize', resizeHandler)\n    return () => {\n      element.removeEventListener('resize', resizeHandler)\n    }\n  }, [element])\n\n  return rect\n}"],"names":["rafId","props","observedNodes","Map","run","changedStates","state","node","a","b","newRect","getBoundingClientRect","rect","some","prop","cb","window","React","useLayoutEffect","useEffect","useRect","nodeRef","useState","current","element","setElement","useReducer","rectReducer","dispatch","initialRectSet","useRef","useIsomorphicLayoutEffect","observer","observe","wasEmpty","undefined","hasRectChanged","callbacks","unobserve","index","length","size","cancelAnimationFrame","action","height","width","defaultEstimateSize","defaultKeyExtractor","defaultMeasureSize","el","horizontal","defaultRangeExtractor","range","start","Math","max","overscan","end","min","arr","i","push","useVirtual","estimateSize","paddingStart","paddingEnd","parentRef","scrollToFn","useObserver","onScrollElement","scrollOffsetFn","keyExtractor","measureSize","rangeExtractor","sizeKey","scrollKey","latestRef","scrollOffset","measurements","outerSize","defaultScrollToFn","useCallback","offset","resolvedScrollToFn","measuredCache","setMeasuredCache","measure","pendingMeasuredCacheIndexesRef","useMemo","slice","key","measuredSize","totalSize","setRange","scrollOffsetFnRef","rangeTimeoutIdRef","cancelAsyncRange","clearTimeout","setTimeout","prevRange","calculateRange","onScroll","event","addEventListener","capture","passive","removeEventListener","measureSizeRef","virtualItems","indexes","k","len","item","measureRef","old","mountedRef","scrollToOffset","toOffset","align","tryScrollToIndex","rest","measurement","scrollToIndex","args","requestAnimationFrame","low","high","getCurrentValue","value","middle","currentValue","findNearestBinarySearch","windowRef","bounds","left","top","setRect","resizeHandler","next","innerHeight","innerWidth","prev","useWindowRect"],"mappings":"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"}